# -*- coding: utf-8 -*-

"""
    greenbyteapi

    This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
"""

from greenbyteapi.api_helper import APIHelper
from greenbyteapi.configuration import Configuration
from greenbyteapi.controllers.base_controller import BaseController
from greenbyteapi.http.auth.custom_header_auth import CustomHeaderAuth
from greenbyteapi.models.task import Task
from greenbyteapi.models.task_category import TaskCategory
from greenbyteapi.models.task_comment import TaskComment
from greenbyteapi.models.tasks_files_response import TasksFilesResponse
from greenbyteapi.models.site_access import SiteAccess
from greenbyteapi.models.device_access import DeviceAccess
from greenbyteapi.models.downtime_event import DowntimeEvent
from greenbyteapi.models.personnel import Personnel
from greenbyteapi.models.organization import Organization
from greenbyteapi.models.hse_incidents_response import HseIncidentsResponse
from greenbyteapi.models.worklog_response import WorklogResponse
from greenbyteapi.exceptions.problem_details_exception import ProblemDetailsException
from greenbyteapi.exceptions.api_exception import APIException

class PlanController(BaseController):

    """A Controller to access Endpoints in the greenbyteapi API."""


    def list_tasks(self,
                   timestamp_start,
                   timestamp_end,
                   device_ids=None,
                   site_ids=None,
                   category_ids=None,
                   state=None,
                   fields=None,
                   page_size=50,
                   page=1,
                   use_utc=False):
        """Does a GET request to /tasks.

        Gets a list of tasks.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            device_ids (list of int, optional): What devices to get tasks
                for.
            site_ids (list of int, optional): What sites to get tasks for.
            category_ids (list of int, optional): What task categories to
                include.
            state (TaskStateEnum, optional): What state of tasks to get:
                resolved and unresolved. If not set, both resolved and
                unresolved tasks are included.
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the `Task` schema
                (See Response Type). By default all fields are included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of Task: Response from the API. A list of tasks matching the
                filter parameters.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/tasks'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'timestampStart': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start),
            'timestampEnd': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end),
            'deviceIds': device_ids,
            'siteIds': site_ids,
            'categoryIds': category_ids,
            'state': state,
            'fields': fields,
            'pageSize': page_size,
            'page': page,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Task.from_dictionary)

    def get_task(self,
                 task_id,
                 use_utc=False):
        """Does a GET request to /tasks/{taskId}.

        Get a single task by ID.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            task_id (int): The id of the task to get.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            Task: Response from the API. A single task.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/tasks/{taskId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'taskId': task_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Task.from_dictionary)

    def list_task_categories(self):
        """Does a GET request to /task-categories.

        Gets a list of task categories.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Returns:
            list of TaskCategory: Response from the API. A list of task
                categories.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/task-categories'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, TaskCategory.from_dictionary)

    def list_comments_for_multiple_tasks(self,
                                         task_ids,
                                         fields=None,
                                         page_size=50,
                                         page=1,
                                         use_utc=False):
        """Does a GET request to /tasks-comments.

        Gets a list of comments belonging to one or more tasks with given
        taskIds.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            task_ids (list of int): An array of taskIds.
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the `TaskComment`
                schema (See Response Type). By default all fields are
                included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of TaskComment: Response from the API. A list of comments
                belonging to the task.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/tasks-comments'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'taskIds': task_ids,
            'fields': fields,
            'pageSize': page_size,
            'page': page,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, TaskComment.from_dictionary)

    def list_task_files(self,
                        task_id,
                        fields=None,
                        page_size=50,
                        page=1,
                        use_utc=False):
        """Does a GET request to /tasks/{taskId}/files.

        Gets a list of files belonging to a task.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            task_id (int): The id of the task.
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the `TaskFile`
                schema (See Response Type). By default all fields are
                included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of TasksFilesResponse: Response from the API. A list with
                information about files belonging to the task.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/tasks/{taskId}/files'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'taskId': task_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'fields': fields,
            'pageSize': page_size,
            'page': page,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, TasksFilesResponse.from_dictionary)

    def download_task_file(self,
                           task_id,
                           file_id):
        """Does a GET request to /tasks/{taskId}/files/{fileId}/content.

        Downloads a file belonging to a task.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            task_id (int): The id of the task.
            file_id (int): The id of the file.

        Returns:
            binary: Response from the API. The contents of a file linked to
                the task.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/tasks/{taskId}/files/{fileId}/content'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'taskId': task_id,
            'fileId': file_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare and execute request
        _request = self.http_client.get(_query_url)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request, binary = True)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return _context.response.raw_body

    def list_site_accesses(self,
                           timestamp_start,
                           timestamp_end,
                           device_ids=None,
                           site_ids=None,
                           fields=None,
                           page_size=50,
                           page=1,
                           use_utc=False):
        """Does a GET request to /site-accesses.

        Gets a list of site accesses.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            device_ids (list of int, optional): What devices to get site
                accesses for.
            site_ids (list of int, optional): What sites to get site accesses
                for.
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the `SiteAccess`
                schema (See Response Type). By default all fields are
                included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of SiteAccess: Response from the API. A list of site accesses
                matching the filter parameters.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/site-accesses'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'timestampStart': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start),
            'timestampEnd': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end),
            'deviceIds': device_ids,
            'siteIds': site_ids,
            'fields': fields,
            'pageSize': page_size,
            'page': page,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, SiteAccess.from_dictionary)

    def get_site_access(self,
                        site_access_id,
                        use_utc=False):
        """Does a GET request to /site-accesses/{siteAccessId}.

        Gets a specific site access.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            site_access_id (int): The id of the site access.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            SiteAccess: Response from the API. A single site access object.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/site-accesses/{siteAccessId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'siteAccessId': site_access_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, SiteAccess.from_dictionary)

    def list_device_accesses_for_multiple_site_accesses(self,
                                                        site_access_ids,
                                                        fields=None,
                                                        page_size=50,
                                                        page=1,
                                                        use_utc=False):
        """Does a GET request to /device-accesses.

        Gets a list of device accesses belonging to site accesses with
        specified SiteAccessIds.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            site_access_ids (list of int): An array of siteAccessIds.
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the `DeviceAccess`
                schema (See Response Type). By default all fields are
                included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of DeviceAccess: Response from the API. A list of device
                accesses.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/device-accesses'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'siteAccessIds': site_access_ids,
            'fields': fields,
            'pageSize': page_size,
            'page': page,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, DeviceAccess.from_dictionary)

    def get_device_access(self,
                          device_access_id,
                          use_utc=False):
        """Does a GET request to /device-accesses/{deviceAccessId}.

        Get a single device access by ID.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            device_access_id (int): The id of the device access to get.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            DeviceAccess: Response from the API. A single device access.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/device-accesses/{deviceAccessId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'deviceAccessId': device_access_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, DeviceAccess.from_dictionary)

    def list_downtime_events(self,
                             timestamp_start,
                             timestamp_end,
                             device_ids=None,
                             site_ids=None,
                             fields=None,
                             page_size=50,
                             page=1,
                             use_utc=False):
        """Does a GET request to /downtime-events.

        Gets a list of downtime events.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            device_ids (list of int, optional): What devices to get downtime
                events for.
            site_ids (list of int, optional): What sites to get downtime
                events for.
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the
                `DowntimeEvent` schema (See Response Type). By default all
                fields are included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of DowntimeEvent: Response from the API. A list of downtime
                events matching the filter parameters.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/downtime-events'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'timestampStart': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start),
            'timestampEnd': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end),
            'deviceIds': device_ids,
            'siteIds': site_ids,
            'fields': fields,
            'pageSize': page_size,
            'page': page,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, DowntimeEvent.from_dictionary)

    def get_downtime_event(self,
                           downtime_event_id,
                           use_utc=False):
        """Does a GET request to /downtime-events/{downtimeEventId}.

        Gets a single downtime event by ID.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            downtime_event_id (int): The id of the downtime event to get.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            DowntimeEvent: Response from the API. A single downtime event.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/downtime-events/{downtimeEventId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'downtimeEventId': downtime_event_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, DowntimeEvent.from_dictionary)

    def list_personnel(self,
                       fields=None,
                       page_size=50,
                       page=1):
        """Does a GET request to /personnel.

        Gets a list of personnel.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            fields (list of string, optional): Which fields to include in the
                response. Valid fields are those defined in the `Personnel`
                schema (See Response Type). By default all fields are
                included.
            page_size (int, optional): The number of items to return per
                page.
            page (int, optional): Which page to return when the number of
                items exceed the page size.

        Returns:
            list of Personnel: Response from the API. A list of personnel
                matching the filter parameters.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/personnel'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'fields': fields,
            'pageSize': page_size,
            'page': page
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Personnel.from_dictionary)

    def get_personnel(self,
                      personnel_id):
        """Does a GET request to /personnel/{personnelId}.

        Gets a single personnel by ID.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Args:
            personnel_id (int): The id of the personnel to get.

        Returns:
            Personnel: Response from the API. A single personnel matching the
                personnel ID.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/personnel/{personnelId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'personnelId': personnel_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Personnel.from_dictionary)

    def list_organizations(self):
        """Does a GET request to /organizations.

        Gets a list of organizations.
        _üîê This endpoint requires the **Plan** endpoint permission._

        Returns:
            list of Organization: Response from the API. A list of
                organizations.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/organizations'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, Organization.from_dictionary)

    def list_hse_incidents(self,
                           timestamp_start,
                           timestamp_end,
                           site_ids=None,
                           state=None,
                           category=None,
                           use_utc=False):
        """Does a GET request to /hse-incidents.

        Gets a list of HSE incidents.
        _üîê This endpoint requires the **Plan** endpoint permission._
        _This is a beta feature. Some details might change before it is
        released as a stable version._

        Args:
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            site_ids (list of int, optional): Which sites to get HSE incidents
                for.
            state (StateEnum, optional): Retrieve HSE incidents with state:
                resolved or unresolved. If not set, both resolved and
                unresolved HSE incidents are included.
            category (HSECategoryEnum, optional): Retrieve HSE incidents with
                a specific category. If not set, HSE incidents of all
                categories are included.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of HseIncidentsResponse: Response from the API. A list of HSE
                incidents matching the filter parameters.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/hse-incidents'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'timestampStart': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start),
            'timestampEnd': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end),
            'siteIds': site_ids,
            'state': state,
            'category': category,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, HseIncidentsResponse.from_dictionary)

    def get_hse_incident(self,
                         hse_incident_id,
                         use_utc=False):
        """Does a GET request to /hse-incidents/{hseIncidentId}.

        Get a single HSE incident by ID.
        _üîê This endpoint requires the **Plan** endpoint permission._
        _This is a beta feature. Some details might change before it is
        released as a stable version._

        Args:
            hse_incident_id (int): The id of the HSE incident to get.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            HseIncidentsResponse: Response from the API. A single HSE
                incident.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/hse-incidents/{hseIncidentId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'hseIncidentId': hse_incident_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, HseIncidentsResponse.from_dictionary)

    def list_worklog_items(self,
                           timestamp_start,
                           timestamp_end,
                           site_ids=None,
                           use_utc=False):
        """Does a GET request to /worklog.

        Gets a list of worklog items.
        _üîê This endpoint requires the **Plan** endpoint permission._
        _This is a beta feature. Some details might change before it is
        released as a stable version._

        Args:
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            site_ids (list of int, optional): What sites to get worklog items
                for.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            list of WorklogResponse: Response from the API. A list of worklog
                items matching the filter parameters.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/worklog'
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'timestampStart': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start),
            'timestampEnd': APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end),
            'siteIds': site_ids,
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, WorklogResponse.from_dictionary)

    def get_worklog_item(self,
                         worklog_item_id,
                         use_utc=False):
        """Does a GET request to /worklog/{worklogItemId}.

        Get a single worklog item by ID.
        _üîê This endpoint requires the **Plan** endpoint permission._
        _This is a beta feature. Some details might change before it is
        released as a stable version._

        Args:
            worklog_item_id (int): The id of the worklog item to get.
            use_utc (bool, optional): Set to true to get timestamps in UTC.

        Returns:
            WorklogResponse: Response from the API. A single worklog item.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/worklog/{worklogItemId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'worklogItemId': worklog_item_id
        })
        _query_builder = Configuration.get_base_uri()
        _query_builder += _url_path
        _query_parameters = {
            'useUtc': use_utc
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomHeaderAuth.apply(_request)
        _context = self.execute_request(_request)

        # Endpoint and global error handling using HTTP status codes.
        if _context.response.status_code == 400:
            raise ProblemDetailsException('The request cannot be fulfilled due to bad syntax.', _context)
        elif _context.response.status_code == 401:
            raise APIException('The request is missing a valid API key. ', _context)
        elif _context.response.status_code == 403:
            raise APIException('One of the following: * The API key does not authorize access to the requested endpoint because of a missing endpoint permission. * The API key does not authorize access to the requested data. Devices, sites or data signals can be limited. ', _context)
        elif _context.response.status_code == 404:
            raise APIException('The requested resource could not be found.', _context)
        elif _context.response.status_code == 405:
            raise APIException('The HTTP method is not allowed for the endpoint.', _context)
        elif _context.response.status_code == 429:
            raise ProblemDetailsException('The API key has been used in too many requests in a given amount of time. The following headers will be set in the response: * `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example   "1m", "12h", or "1d"). * `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests   for this period. * `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601   format) when the remaining number of requests resets.  The limit is currently 1,000 requests/minute per API key and IP address. ', _context)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, WorklogResponse.from_dictionary)
