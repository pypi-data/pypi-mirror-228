from __future__ import annotations

from collections import namedtuple
import importlib
import re
import string
from pathlib import Path

import inflect
from jinja2 import Environment, PackageLoader

from .version import version

from typing import Optional, TYPE_CHECKING

from ophyd import EpicsSignal


if TYPE_CHECKING:
    from .models import OperationalArea


def _validate_class(name: str, pattern: str = None, replace: str = " ") -> str:

    if not pattern:
        pattern = "[^A-Za-z0-9_]"

    return re.sub(pattern, replace, name)


def _validate_name(name: str, pattern: str = None, replace: str = "") -> str:

    name = name.replace(" ", "_")
    name = name.replace(":", "_")
    name = name.replace("-", "_")
    name = name.replace("=", "_")
    name = name.replace("+", "_plus_")
    name = name.replace("-", "_")
    name = name.replace(".", "")
    name = name.replace("/", "_")

    if not pattern:
        pattern = "[^A-Za-z0-9_]"

    name = re.sub(pattern, replace, name)

    return re.sub("_+", "_", name)


def _classname(name: str) -> str:

    def convert_to_uppercase(m: re.Match) -> str:
        return m.group(1) + m.group(2).upper()

    name = re.sub(r"(^|\s)(\S)", convert_to_uppercase, _validate_class(name).strip())

    parts = name.split()
    ret = parts[0]
    for part in parts[1:]:
        if (ret[-1] in string.ascii_uppercase and part[0] in string.ascii_uppercase) or (
            ret[-1] in string.digits and part[0] in string.digits
        ):

            ret += "_" + part
        else:
            ret += part

    return ret


def _varname(name: str, prefix: Optional(str) = None) -> str:
    if prefix and name != prefix:
        name = name.removeprefix(prefix)

    name = name.strip()

    if name[0].isdigit():
        p = inflect.engine()

        head, *tail = name.split()

        word = p.number_to_words(head)

        name = " ".join([word] + tail)

    return _validate_name(name).lower()


def _generated() -> str:
    return f"Generated by csbs-import {version()}"


def _filter_func(filename):
    return filename.endswith(".py.jinja2")


def _imports(opa, lookup):
    def _node_imports(node):
        if node.isLeaf() and lookup(node.typeName()):
            yield lookup(node.typeName()).__module__

        else:
            for child in node.children:
                yield from _node_imports(child)

    result = set(_node_imports(opa))

    return sorted(result)


class RegistryLookup:
    def __init__(self, builtin, extra):
        self._builtin = importlib.import_module(builtin)

        if extra:
            module_name, registry_name = extra.split(":")

            module = importlib.import_module(module_name)
            self._extra = getattr(module, registry_name)
        else:
            self._extra = None

    def __call__(self, name):
        res = None
        if self._extra:
            try:
                res = self._extra()[name]
            except KeyError:
                res = None

        if not res:
            try:
                res = self._builtin.registry()[name]
            except KeyError:
                res = None

        return res


def generate_opa_code(opa: OperationalArea, config: dict[str:str]) -> None:

    ImportDetails = namedtuple("ImportDetails", ["module", "callable"])

    parent = Path(config["output_path"])
    parent.mkdir(parents=True, exist_ok=True)

    ophydClassLookup = RegistryLookup(builtin="as_acquisition_library.devices", extra=config.get("area_device_registry", None))
    mockClassLookup = RegistryLookup(builtin="acquisition_mocks", extra=config.get("area_mock_registry", None))

    env = Environment(loader=PackageLoader("csbs_import"), extensions=["jinja2.ext.DebugExtension"])
    env.filters["classname"] = _classname
    env.filters["varname"] = _varname
    env.globals["ophydClassLookup"] = ophydClassLookup
    env.globals["mockClassLookup"] = mockClassLookup
    env.trim_blocks = True

    if "component_factory" in config:
        module, callable = config["component_factory"].split(":")

    else:
        module, callable = "", "default_component_factory"

    component_factory = ImportDetails(module, callable)

    for template_name in env.list_templates(filter_func=_filter_func):
        template = env.get_template(template_name)
        output_name = (parent / template_name).with_suffix("")
        print(f"Generating {output_name} from {template_name}")
        with output_name.open("w") as f:
            f.write(template.render(opa=opa,
                                    component_factory=component_factory,
                                    mixins_import=config.get("mixins_import", None),
                                    ophyd_imports=_imports(opa, ophydClassLookup),
                                    mock_imports=_imports(opa, mockClassLookup),
                                    generated=_generated()))
