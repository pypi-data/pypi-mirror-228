{"version":3,"file":"node_modules_rxjs__esm5_internal_operators_ignoreElements_js-node_modules_rxjs__esm5_internal-39ebda.8aaece873db64d43dcda.js","mappings":";;;;;;;;;;;;;;;;AAE2B;AA8BG;AAC5B,IAAO,SAAS;QACd,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,sBAAsB,EAAE,CAAC,CAAC;IACnD,CAAC,CAAC;AACJ,CAAC;AAED;IAAA;IAIA,CAAC;IAHC;QACE,OAAO,MAAM,CAAC,SAAS,CAAC,IAAI,wBAAwB,CAAC,UAAU,CAAC,CAAC,CAAC;IACpE,CAAC;IACH;AAAA,CAAC;AAOD;IAA0C,oDAAa;IAAvD;;IAIA,CAAC;IAHW;IAEV,CAAC;IACH;AAAA,CAAC,CAJyC,UAAU,GAInD;;;;;;;;;;;;;;;;;;;;;ACpD0B;AAGS;AACT;AA+DJ;AACrB,IAAO,SAAS,mBAAmB,CAAC,MAAqB;QACvD,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC;IACpC,CAAC,CAAC;AACJ,CAAC;AAED;IACE,oBAAoB,cAAsD,EACtD,KAAwB;QADxB,mBAAc,GAAd,cAAc,CAAwC;QACtD,UAAK,GAAL,KAAK,CAAmB;QACxB,aAAQ,GAAR;IACpB,CAAC;IACD;QACE,OAAO,MAAM,CAAC,SAAS,CAAC,IAAI,aAAa,CAAC,UAAU,EAAE;IACxD,CAAC;IACH;AAAA,CAAC;AAQD;IAA+B,yCAAa;IAS1C,kDAAY,WAA0B,EAC1B;QADZ,YAII,kBAAM,WAAW,CAAC,SAYnB;QAtBK,cAAQ,GAAyB,IAAI,CAAC;QAEtC,eAAS,8CAAyB,CAAI;QAEtC,kBAAY,4CAAiB;QAOjC,KAAI,CAAC,SAAS,GAAG,+CAAK;QACtB,KAAI,CAAC,YAAY,GAAG,kDAAQ;QAC5B,IAAI,UAAU,CAAC,cAAc,CAAC,EAAE;YAC9B,4DAAK,IAAQ,GAAG,KAAI,CAAC;YACrB,KAAI,CAAC,QAAQ,GAAG;SACjB;;YACC,KAAI,CAAC,QAAQ,GAAG;YAChB,KAAI,CAAC,QAAQ,GAAG,cAAc,CAAC;YAC/B,KAAI,CAAC,SAAS,GAAG,cAAc,CAAC,KAAK,8CAAI;YACzC,KAAI,CAAC,YAAY,GAAG,cAAc,CAAC,kDAAQ;SAC5C;;IACH,CAAC;IAEH;QACE,IAAI;YACF;SACD;QAAC;YACA,IAAI,CAAC;YACL,OAAO;SACR;QACD;IACF,CAAC;IAED;QACE,IAAI;YACF;SACD;QAAC;YACA,IAAI,CAAC;YACL,OAAO;SACR;QACD;IACF,CAAC;IAED;QACE,IAAI;YACF;SACD;QAAC;YACA,IAAI,CAAC;YACL,OAAO;SACR;QACD;IACF,CAAC;IACH;AAAA,CAAC,CAxD8B,UAAU,GAwDxC;;;;;;;;;;;;;;;;ACjJD,MAAM,UAAU,IAAI,KAAK,CAAC","sources":["webpack://@datalayer/jupyter-react/../../../../../node_modules/rxjs/src/internal/operators/ignoreElements.ts","webpack://@datalayer/jupyter-react/../../../../../node_modules/rxjs/src/internal/operators/tap.ts","webpack://@datalayer/jupyter-react/../../../../../node_modules/rxjs/src/internal/util/noop.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * ## Examples\n * ### Ignores emitted values, reacts to observable's completion.\n * ```ts\n * import { of } from 'rxjs';\n * import { ignoreElements } from 'rxjs/operators';\n *\n * of('you', 'talking', 'to', 'me').pipe(\n *   ignoreElements(),\n * )\n * .subscribe(\n *   word => console.log(word),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'the end'\n * ```\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport function ignoreElements(): OperatorFunction<any, never> {\n  return function ignoreElementsOperatorFunction(source: Observable<any>) {\n    return source.lift(new IgnoreElementsOperator());\n  };\n}\n\nclass IgnoreElementsOperator<T, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IgnoreElementsSubscriber<T> extends Subscriber<T> {\n  protected _next(unused: T): void {\n    // Do nothing\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of an error callback */\nexport function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { tap, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n"],"names":[],"sourceRoot":""}