// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AKIDADEVICEPROGRAMFB_AKIDA_FB_H_
#define FLATBUFFERS_GENERATED_AKIDADEVICEPROGRAMFB_AKIDA_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "akida_np_info_generated.h"

namespace akida {
namespace fb {

struct NpTrack;
struct NpTrackBuilder;

struct Fnp2FilterTrack;
struct Fnp2FilterTrackBuilder;

struct Record;
struct RecordBuilder;

struct Pass;
struct PassBuilder;

struct DmaConfigHeader;

struct LearningLayer;
struct LearningLayerBuilder;

struct Program;
struct ProgramBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DmaConfigHeader FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t w1_;
  uint32_t w2_;

 public:
  DmaConfigHeader()
      : w1_(0),
        w2_(0) {
  }
  DmaConfigHeader(uint32_t _w1, uint32_t _w2)
      : w1_(flatbuffers::EndianScalar(_w1)),
        w2_(flatbuffers::EndianScalar(_w2)) {
  }
  uint32_t w1() const {
    return flatbuffers::EndianScalar(w1_);
  }
  uint32_t w2() const {
    return flatbuffers::EndianScalar(w2_);
  }
};
FLATBUFFERS_STRUCT_END(DmaConfigHeader, 8);

struct NpTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NpTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct NpTrackBuilder {
  typedef NpTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(NpTrack::VT_DATA, data);
  }
  explicit NpTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NpTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NpTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<NpTrack> CreateNpTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  NpTrackBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<NpTrack> CreateNpTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return akida::fb::CreateNpTrack(
      _fbb,
      data__);
}

struct Fnp2FilterTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Fnp2FilterTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NP = 4,
    VT_DATA = 6
  };
  const akida::fb::NPIdent *np() const {
    return GetStruct<const akida::fb::NPIdent *>(VT_NP);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<akida::fb::NPIdent>(verifier, VT_NP, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Fnp2FilterTrackBuilder {
  typedef Fnp2FilterTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_np(const akida::fb::NPIdent *np) {
    fbb_.AddStruct(Fnp2FilterTrack::VT_NP, np);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(Fnp2FilterTrack::VT_DATA, data);
  }
  explicit Fnp2FilterTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fnp2FilterTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fnp2FilterTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fnp2FilterTrack> CreateFnp2FilterTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    const akida::fb::NPIdent *np = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  Fnp2FilterTrackBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_np(np);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fnp2FilterTrack> CreateFnp2FilterTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const akida::fb::NPIdent *np = nullptr,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return akida::fb::CreateFnp2FilterTrack(
      _fbb,
      np,
      data__);
}

struct Record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NP_TRACKS = 4,
    VT_FNP2_TRACK = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>> *np_tracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>> *>(VT_NP_TRACKS);
  }
  const akida::fb::Fnp2FilterTrack *fnp2_track() const {
    return GetPointer<const akida::fb::Fnp2FilterTrack *>(VT_FNP2_TRACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NP_TRACKS) &&
           verifier.VerifyVector(np_tracks()) &&
           verifier.VerifyVectorOfTables(np_tracks()) &&
           VerifyOffset(verifier, VT_FNP2_TRACK) &&
           verifier.VerifyTable(fnp2_track()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  typedef Record Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_np_tracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>>> np_tracks) {
    fbb_.AddOffset(Record::VT_NP_TRACKS, np_tracks);
  }
  void add_fnp2_track(flatbuffers::Offset<akida::fb::Fnp2FilterTrack> fnp2_track) {
    fbb_.AddOffset(Record::VT_FNP2_TRACK, fnp2_track);
  }
  explicit RecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Record> CreateRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>>> np_tracks = 0,
    flatbuffers::Offset<akida::fb::Fnp2FilterTrack> fnp2_track = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_fnp2_track(fnp2_track);
  builder_.add_np_tracks(np_tracks);
  return builder_.Finish();
}

inline flatbuffers::Offset<Record> CreateRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<akida::fb::NpTrack>> *np_tracks = nullptr,
    flatbuffers::Offset<akida::fb::Fnp2FilterTrack> fnp2_track = 0) {
  auto np_tracks__ = np_tracks ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::NpTrack>>(*np_tracks) : 0;
  return akida::fb::CreateRecord(
      _fbb,
      np_tracks__,
      fnp2_track);
}

struct Pass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct PassBuilder {
  typedef Pass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>>> records) {
    fbb_.AddOffset(Pass::VT_RECORDS, records);
  }
  explicit PassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pass>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pass> CreatePass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>>> records = 0) {
  PassBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pass> CreatePassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<akida::fb::Record>> *records = nullptr) {
  auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::Record>>(*records) : 0;
  return akida::fb::CreatePass(
      _fbb,
      records__);
}

struct LearningLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LearningLayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NP = 4,
    VT_LEARNING_REGISTERS = 6,
    VT_INFERENCE_REGISTERS = 8,
    VT_RAM = 10,
    VT_LEARN_MEM_SIZE = 12,
    VT_UPDATE_LEARN_MEM_HDR = 14
  };
  const akida::fb::NPIdent *np() const {
    return GetStruct<const akida::fb::NPIdent *>(VT_NP);
  }
  const akida::fb::Record *learning_registers() const {
    return GetPointer<const akida::fb::Record *>(VT_LEARNING_REGISTERS);
  }
  const akida::fb::Record *inference_registers() const {
    return GetPointer<const akida::fb::Record *>(VT_INFERENCE_REGISTERS);
  }
  const akida::fb::Record *ram() const {
    return GetPointer<const akida::fb::Record *>(VT_RAM);
  }
  uint32_t learn_mem_size() const {
    return GetField<uint32_t>(VT_LEARN_MEM_SIZE, 0);
  }
  const akida::fb::DmaConfigHeader *update_learn_mem_hdr() const {
    return GetStruct<const akida::fb::DmaConfigHeader *>(VT_UPDATE_LEARN_MEM_HDR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<akida::fb::NPIdent>(verifier, VT_NP, 1) &&
           VerifyOffset(verifier, VT_LEARNING_REGISTERS) &&
           verifier.VerifyTable(learning_registers()) &&
           VerifyOffset(verifier, VT_INFERENCE_REGISTERS) &&
           verifier.VerifyTable(inference_registers()) &&
           VerifyOffset(verifier, VT_RAM) &&
           verifier.VerifyTable(ram()) &&
           VerifyField<uint32_t>(verifier, VT_LEARN_MEM_SIZE, 4) &&
           VerifyField<akida::fb::DmaConfigHeader>(verifier, VT_UPDATE_LEARN_MEM_HDR, 4) &&
           verifier.EndTable();
  }
};

struct LearningLayerBuilder {
  typedef LearningLayer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_np(const akida::fb::NPIdent *np) {
    fbb_.AddStruct(LearningLayer::VT_NP, np);
  }
  void add_learning_registers(flatbuffers::Offset<akida::fb::Record> learning_registers) {
    fbb_.AddOffset(LearningLayer::VT_LEARNING_REGISTERS, learning_registers);
  }
  void add_inference_registers(flatbuffers::Offset<akida::fb::Record> inference_registers) {
    fbb_.AddOffset(LearningLayer::VT_INFERENCE_REGISTERS, inference_registers);
  }
  void add_ram(flatbuffers::Offset<akida::fb::Record> ram) {
    fbb_.AddOffset(LearningLayer::VT_RAM, ram);
  }
  void add_learn_mem_size(uint32_t learn_mem_size) {
    fbb_.AddElement<uint32_t>(LearningLayer::VT_LEARN_MEM_SIZE, learn_mem_size, 0);
  }
  void add_update_learn_mem_hdr(const akida::fb::DmaConfigHeader *update_learn_mem_hdr) {
    fbb_.AddStruct(LearningLayer::VT_UPDATE_LEARN_MEM_HDR, update_learn_mem_hdr);
  }
  explicit LearningLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LearningLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LearningLayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<LearningLayer> CreateLearningLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    const akida::fb::NPIdent *np = nullptr,
    flatbuffers::Offset<akida::fb::Record> learning_registers = 0,
    flatbuffers::Offset<akida::fb::Record> inference_registers = 0,
    flatbuffers::Offset<akida::fb::Record> ram = 0,
    uint32_t learn_mem_size = 0,
    const akida::fb::DmaConfigHeader *update_learn_mem_hdr = nullptr) {
  LearningLayerBuilder builder_(_fbb);
  builder_.add_update_learn_mem_hdr(update_learn_mem_hdr);
  builder_.add_learn_mem_size(learn_mem_size);
  builder_.add_ram(ram);
  builder_.add_inference_registers(inference_registers);
  builder_.add_learning_registers(learning_registers);
  builder_.add_np(np);
  return builder_.Finish();
}

struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PASSES = 4,
    VT_LEARNING_LAYER = 6,
    VT_DUMMY_DESC_HDR = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>> *passes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>> *>(VT_PASSES);
  }
  const akida::fb::LearningLayer *learning_layer() const {
    return GetPointer<const akida::fb::LearningLayer *>(VT_LEARNING_LAYER);
  }
  const akida::fb::DmaConfigHeader *dummy_desc_hdr() const {
    return GetStruct<const akida::fb::DmaConfigHeader *>(VT_DUMMY_DESC_HDR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PASSES) &&
           verifier.VerifyVector(passes()) &&
           verifier.VerifyVectorOfTables(passes()) &&
           VerifyOffset(verifier, VT_LEARNING_LAYER) &&
           verifier.VerifyTable(learning_layer()) &&
           VerifyField<akida::fb::DmaConfigHeader>(verifier, VT_DUMMY_DESC_HDR, 4) &&
           verifier.EndTable();
  }
};

struct ProgramBuilder {
  typedef Program Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_passes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>>> passes) {
    fbb_.AddOffset(Program::VT_PASSES, passes);
  }
  void add_learning_layer(flatbuffers::Offset<akida::fb::LearningLayer> learning_layer) {
    fbb_.AddOffset(Program::VT_LEARNING_LAYER, learning_layer);
  }
  void add_dummy_desc_hdr(const akida::fb::DmaConfigHeader *dummy_desc_hdr) {
    fbb_.AddStruct(Program::VT_DUMMY_DESC_HDR, dummy_desc_hdr);
  }
  explicit ProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Program> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Program>(end);
    return o;
  }
};

inline flatbuffers::Offset<Program> CreateProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>>> passes = 0,
    flatbuffers::Offset<akida::fb::LearningLayer> learning_layer = 0,
    const akida::fb::DmaConfigHeader *dummy_desc_hdr = nullptr) {
  ProgramBuilder builder_(_fbb);
  builder_.add_dummy_desc_hdr(dummy_desc_hdr);
  builder_.add_learning_layer(learning_layer);
  builder_.add_passes(passes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Program> CreateProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<akida::fb::Pass>> *passes = nullptr,
    flatbuffers::Offset<akida::fb::LearningLayer> learning_layer = 0,
    const akida::fb::DmaConfigHeader *dummy_desc_hdr = nullptr) {
  auto passes__ = passes ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::Pass>>(*passes) : 0;
  return akida::fb::CreateProgram(
      _fbb,
      passes__,
      learning_layer,
      dummy_desc_hdr);
}

inline const akida::fb::Program *GetProgram(const void *buf) {
  return flatbuffers::GetRoot<akida::fb::Program>(buf);
}

inline const akida::fb::Program *GetSizePrefixedProgram(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<akida::fb::Program>(buf);
}

inline bool VerifyProgramBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<akida::fb::Program>(nullptr);
}

inline bool VerifySizePrefixedProgramBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<akida::fb::Program>(nullptr);
}

inline void FinishProgramBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<akida::fb::Program> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProgramBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<akida::fb::Program> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fb
}  // namespace akida

#endif  // FLATBUFFERS_GENERATED_AKIDADEVICEPROGRAMFB_AKIDA_FB_H_
